//The approach here is to assign the connected nodes into different groups and consider only the ones that have only 1 infected node. Among them, we check which group has more nodes that could be saved.
// We will return the node that saves the maximum nodes
//Time Complexity: O(n^2)
//Space Complexity: O(n^2)
import java.util.Arrays;

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int [] colors = new int[n];
        Arrays.fill(colors, -1);
        int color = 0;
        for(int i = 0; i< n; i++){
            if(colors[i] == -1){
                //not visited, doesn't have color
                dfs(graph, colors, i, color);
            }
            color++;
        }
        int[] groups = new int[color];
        for(int i = 0; i<n; i++){
            int cl = colors[i];
            groups[cl]++;
        }
        int [] initGroups = new int[color];
        for(int node: initial){
            int c = colors[node];
            initGroups[c]++;
        }
        int result = Integer.MAX_VALUE;
        for(int node: initial){
            int col = colors[node];
            //how many are initially infected for that col/group
            int cnt = initGroups[col];
            if(cnt == 1){
                if(result == Integer.MAX_VALUE){
                    result = node;
                } else if(groups[col] > groups[colors[result]]){
                    //compare if curr node is saving more nodes than earlier result
                    result = node;
                } else if(groups[col] == groups[colors[result]] && node < result){
                    //curr node and earlier result node are saving same number of node
                    //but curr node < smaller
                    result = node;
                }
            }
        }
        if(result == Integer.MAX_VALUE){
            for(int node: initial){
                result = Math.min(result, node);
            }
        }
        return result;
    }

    private void dfs(int[][] graph, int[] colors, int i, int col){
        //base
        if(colors[i] != -1) return;
        //logic
        colors[i] = col;
        for(int j = 0; j < graph.length; j++){
            if(graph[i][j] == 1){
                dfs(graph, colors, j, col);
            }
        }
    }
}